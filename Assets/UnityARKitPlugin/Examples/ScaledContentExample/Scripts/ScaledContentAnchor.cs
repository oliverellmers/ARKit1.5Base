using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR.iOS;
using UnityEngine.EventSystems;

public class ScaledContentAnchor : MonoBehaviour {

	public CameraScaler cameraScaler;
	public GameObject contentRoot;
	public LayerMask collisionLayerMask;

	bool HitTestWithResultType(ARPoint point, ARHitTestResultType resultTypes)
	{
		List<ARHitTestResult> hitResults = UnityARSessionNativeInterface.GetARSessionNativeInterface().HitTest(point, resultTypes);
		if (hitResults.Count == 1)
		{
			foreach (var hitResult in hitResults)
			{
				contentRoot.SetActive (true);
				cameraScaler.scaledObjectOrigin = UnityARMatrixOps.GetPosition(hitResult.worldTransform);
				return true;
			}
		}
		return false;
	}

	// Taken from http://answers.unity3d.com/questions/1115464/ispointerovergameobject-not-working-with-touch-inp.html#answer-1115473
	private bool IsPointerOverUIObject()
	{
		PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);
		eventDataCurrentPosition.position = new Vector2(Input.mousePosition.x, Input.mousePosition.y);
		List<RaycastResult> results = new List<RaycastResult>();
		EventSystem.current.RaycastAll(eventDataCurrentPosition, results);
		return results.Count > 0;
	}

	// Update is called once per frame
	void Update () {

		#if !UNITY_EDITOR	

		if (!IsPointerOverUIObject() && Input.touchCount == 1 && cameraScaler != null && Input.GetTouch(0).phase == TouchPhase.Began)
		{
			var touch = Input.GetTouch(0);
			var screenPosition = Camera.main.ScreenToViewportPoint(touch.position);
			ARPoint point = new ARPoint
			{
				x = screenPosition.x,
				y = screenPosition.y
			};

            // prioritize reults types
            ARHitTestResultType[] resultTypes = {
                ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent, 
				// if you want to use infinite planes use this:
				//ARHitTestResultType.ARHitTestResultTypeExistingPlane,
				//ARHitTestResultType.ARHitTestResultTypeHorizontalPlane,
                ARHitTestResultType.ARHitTestResultTypeEstimatedHorizontalPlane,
				ARHitTestResultType.ARHitTestResultTypeFeaturePoint
			};

			foreach (ARHitTestResultType resultType in resultTypes)
			{
				if (HitTestWithResultType(point, resultType))
				{
					return;
				}
			}
		}

		#else
		if (Input.GetMouseButtonDown (0) && cameraScaler != null) {
			Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);
			RaycastHit hit;

			//we'll try to hit one of the plane collider gameobjects that were generated by the plugin
			//effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
			if (Physics.Raycast (ray, out hit, 3.0f, collisionLayerMask)) {
				//we're going to get the position from the contact point
				cameraScaler.scaledObjectOrigin = hit.point;
				contentRoot.SetActive(true);
			}
		}	
			
		#endif
	}
}
